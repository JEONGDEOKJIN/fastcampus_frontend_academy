


// 🟦 데이터 가져오기

    // root 가 반복되니까, 변수화, 시키기 ⭐⭐⭐ 
    const container = document.getElementById('root');

    // XMLHttpRequest 객체를 ajax 에 저장하기 
    const ajax = new XMLHttpRequest();

    // [콘텐츠가 보여지게] 영역만 
    const content = document.createElement('div');

    // URL 주소는 변경될 수 있기 때문에, 변수로 바꿀 수 있는 부분을 바꾸기 
    const NEWS_URL = 'https://api.hnpwa.com/v0/news/1.json'

    const CONTENT_URL = 'https://api.hnpwa.com/v0/item/@id.json'


    // 네트워크에서 데이터 가져오는 함수
        // input : URL | return : (parse처리된) 객체 
    function getData(url) {
        // 연결? 하기
        ajax.open('GET', url, false);

        // 실제로 데이터를 가져오는 순간.
        ajax.send();

        return JSON.parse(ajax.response);
    }


// 🟦 처리해서, 보여주기 
    // UI 로 보여주기 
    const ul = document.createElement('ul');

    
    // '라우터'에 들어가게 하기 위해서, '목록 화면' 을 '함수' 로 만들기
    function newsFeed() {
        // JSON 형식의 response 데이터를 > 객체로 변환
        const newsFeed = getData(NEWS_URL);
            // ⭐⭐⭐ 데이터를 가져오는 부분도 함수에 넣어줌 ⭐⭐⭐

        // 뉴스 목록이 들어가기 위한 '배열' 
            const newsList = [];

        // 뉴스 목록 중 첫 번째 ul 
        newsList.push(`<ul>`);

        // 뉴스 목록에 들어갈 li 들 
        for (let i = 0; i < 10; i++) {
            newsList.push (`
            <li> 
                <a href = "#${newsFeed[i].id}"> 
                ${newsFeed[i].title} (${newsFeed[i].comments_count}) 
                </a>
            </li>
            `);
        }

        // ul 로 닫아주기
        newsList.push(`</ul>`);

        // appendChild 할게 아니라, Overwrite 할 것 임! ⭐⭐⭐⭐⭐⭐ 
        container.innerHTML = newsList.join('');
            // [주의점]
                // join 메소드는 특정 문자를 seperator 로 사용하게 됨. 
                // 지금은 딱히 seperator 를 사용하지 않아도 되는 상황. 
                // 다만, 좀 더 주의깊게 봐야할 수도 있음. ⭐⭐⭐ 
    }

    // '라우터' 호출에 반응할 수 있게, 익명함수에서 탈출! 
    function newsDetail() {
        const id = location.hash.substring(1);

        // JSON 데이터를 객체로 변환 ✅✅(오타났었음)
        const newsContent = getData(CONTENT_URL.replace('@id', id));
        
        // 제목에 내용 넣고 > div 태그에 붙이기  
        const title = document.createElement('h1');
        
        // ⭐⭐root class divs 를 담고 있는 container의 기존 내용물을 날려버리기⭐⭐
        // container.innerHTML = "";
            // [느낀점] 
                // 이 순간, 목록과 내용이 분리되면서, '누적되어서 내용물이 보이는 문제' 가 사라졌다. ⭐⭐⭐ 
                // 그리고, 이걸 놔두는게 아니라, 밑에 다시 내용을 추가 한다. 
                // 지우는 동시에, 새로운 내용을 쓰는거지. ⭐⭐⭐⭐⭐⭐
                    // 그걸 '비우는 코드' , '내용 채우는 코드' 따로 두는게 아니라, 하나에! 

        // 🔷 내용화면, 다시 구성 🔷
        container.innerHTML = `
            <h1> ${newsContent.title}</h1> 

            <a href = "#"> 목록으로 </a>

            `;
    }



    // '내용화면, 목록화면을 호출할 수 있는 라우터' 만들기 
    function router () {

        const routePath = location.hash;
            // [해석]
                // 현재 위치(클릭된 것의 위치?) 의 '해시값' 을 가져온다. 
                // 라우터의 화면을 전환시키는 용도 이기 때문에, routePath 라고 이름 붙인다. 

        // 라우트hash 가 아무것도 없을 때 = 첫 진입 ⭐⭐⭐⭐⭐ 
        if (routePath === '') {
            // location hash 에 # 만 있으면 -> 빈 값을 반환 so, true 가 되어 작동

            // 글 목록이 보임
            newsFeed();
        } else {
            // 글 내용 
            newsDetail();
        }
    }


    // 클릭 이벤트 
    window.addEventListener('hashchange', router);
        // [해석]
            // '라우터' 는 '특정 조건' 에서 '특정 화면' 을 보여준다. ⭐⭐⭐⭐⭐⭐ 
            // 그러면, 어떤 조건에서? 어떤 트리거에서? 
                // ⭐⭐⭐ 'hash가 이렇게 바뀌었을 때 (북마크가 이렇게 바뀌었을 때)' -> '이런 화면' 을 보여준다. ⭐⭐⭐
            // 결과적으로, hash 가 바뀔 때 > router 가 호출 될 것. 
            // 그러면, '어떤 hash냐?' 에 따라서 > '글 목록', '글 내용' 을 보여주면 됨. ⭐⭐⭐


    // 라우터로 특정조건에서, 특정 화면을 보여주게 하기 실행     
    router();






// 📚 수업 과정 

// 🟦 화면 처리기 = '라우터' 만들기 

    // 🔷 지금까지 만든 것 
        // 목록화면 -> 제목 클릭 -> 내용을 api 로 불러와서, 타이틀 표시 
        // [문제점]
            // '목록화면' 과 '내용화면' 이 같이 보임. 
            // 내용이 하나만 나오지 않고, 계속 추가 됨. 

        // [앞으로 할 것]
            // 우선, ⭐'한번에 하나의 화면만 보이는 구조'⭐ 를 먼저 구축 하기

    // 🔷 ⭐'한번에 하나의 화면만 보이는 구조'⭐ 만들기
        // [느낀점]
            // 아, 이걸, '한번에 하나의 화면만 보이는 구조' 라고 이야기 할 수 있겠구나. 
            // 지금 뭘 하고 있고, 왜 이걸 하고 있는지를 알 수 있어서 좋다. 

        // [생각의 흐름]
            // ⭐'왜 같이 보이는가'⭐ 를 알면, ⭐어떻게 하면, 다르게 보이게 할까⭐, 를 알 수 있음! 
            // 1. html 에는 div 태그만 있음. 
            // 2. div 는 container 변수에 들어감. 
            // 3. container 에 ul, content(h1 태그에 뉴스api의 title이 들어감) 를 '추가' 함 
            // 4. '추가' = '기존것을 유지' 한다는 것. -> so, 내용화면으로 들어갔을 때, 목록화면이 유지될 수 밖에 없음. 
            // 5. 대안 
                // ⭐⭐⭐ 내용화면으로 넘어가면, 목록화면을 다 지워보기 ⭐⭐⭐⭐⭐  
                // ⭐⭐⭐ appendchild 를 쓰지 않아보기 ⭐⭐⭐⭐⭐ 
            
    
    // 🔷 [내용화면 구조 짜기] ⭐⭐⭐ 
        // '내용화면' 으로 넘어가는 부분 = hash change event handler 부분. 
        
        // [현재, hash change event handler의 문제점]
            // DOM API를 사용해서, 마크업 구조의 파악이 어려운 문제. 
            // SO, '문자열 방식(innerHTML)' 으로 리택토링 하기 

        // [내용화면으로 넘어가면, 목록화면을 다 지워보기] ⭐⭐⭐ 
            // 🔷 내용화면, 다시 구성 🔷
                // container.innerHTML = `
                // <h1> ${newsContent.title}</h1> 

                // <a href = "#"> 목록으로 </a>

                // `;
                // 여기까지 오면, 완전히 다른 화면으로 넘어갔구나! 라고 느끼게 됨 ⭐⭐⭐ 
            // [시사점]
                // 그냥, 따라서 쳤었어. 
                // 근데, 보니까, 그렇게 코드를 작성하는 이유와 의도가 있었어 ⭐⭐⭐
                // 그 이유와 의도를 알아야만 해 ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ 


    // 🔷 ['목록화면' 구조 짜보기] ⭐⭐⭐  

        // [현재상황]
            // 현재는 container 에 그대로, appendChild 된 구조 임. 
        // [필요한 것]
            // '내용화면' 에서 '목록화면'으로 들어갔을 때, '내용화면' 이 지워지고, overwrite 되어야 함. 

        // [내용화면과 비교]
            // 내용화면은 문자열 하나로, 화면 하나를 만들 수 있음. 
            // 목록화면은 문자열 하나로, 화면 하나를 만들 수 없음. ⭐⭐⭐ 왜? 

            // '⭐⭐내용 화면이 필요로 하는 마크업 구조⭐⭐' 는, 
                // 1) 기존 태그 유지 + 2) 새로운 태그 추가 3) 반복문이 필요  
                    // `
                    // <ul>
                    //     <li>
                    //         <a> </a>
                    //     </li>
                    //     <li>
                    //         <a> </a>
                    //     </li>
                    //     <li>
                    //         <a> </a>
                    //     </li>
                    //     <li>
                    //         <a> </a>
                    //     </li>
                    // </ul>
                    // `

            // 이러한 ⭐'마크업 구조' 를 '코드'⭐ 로 표현하면? (굉장히 중요한 접근이라고 생각함⭐⭐⭐⭐⭐⭐⭐⭐⭐)
                // 1) ul 태그가 있음. 
                // 2) 그 다음, li 태그가 반복되면서 표현되고 있음.

                // 3) 구체적으로 보면
                    // ul 만들고 > li 만들고 
                    // 기존에 만들었던 li 유지하면서, li 추가하고 > 기존 유지 + li 추가 
                    // 그 다음 ul 로 닫아야 함. 
                    // 이걸 어떻게 코드로 표현할 수 있을까?⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐  

        // [코드로 해보면?] ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐ 
            // 1. '배열' 을 만든다. 
            // 2. 그 안에 차곡차곡 쌓는다. 
            // 3. 그리고, '문자열' 로 변환한다.
                // [느낀점]
                    // 여기서, '배열' 을 사용할 생각을 어케 하는거지 대체 
                    // join 을 쓸 생각을 어떻게 한걸까? 
                        // innerHTML 에 '문자열' 이 들어가야 해서? 
                        // 그러면, 어떤 데이터 타입, input, output 을 주의깊게 봐둬야 하는 걸까? ⭐⭐⭐ 



        // 🔷 '라우터를 작성' 하기 
            // 의의 
                // '목록화면 '과 '내용화면' 간 '전환' 하는 상태를 만들어보기
                // 여러개의 글을 보면서 '탐색' 할 수 있도록 만들기 
                // 내용에서, 하나의 글만 보고 끝나지 않도록

            // 라우터란? ⭐⭐⭐⭐⭐  
                // '중계기' 의미 
                // '어떤 상태' 에서는 'A 화면' 을 보여준다. 
                // '어떤 상태' 에서는 'B 화면' 을 보여준다. 
                // '어떤 상태' 에서는 'C 화면' 을 보여준다. 
            
            // '라우터' 에게 '필요한 기능' 
                // '화면 전환' 
                // '사용자는 단 1개의 화면' 만을 보게 될 것. 
                    // 현재 코드에서는 '글 목록 화면', '글 내용 화면' 이 있음. 
                // 내용화면, 목록화면 모두 ⭐⭐'함수로 묶여야'⭐⭐ > 특정 상황에서, 이 화면을 보여줘! 가 가능 하다. ⭐⭐⭐⭐⭐ 

            // 🔷 [목록화면을 함수로 만들기]
                // 


            // 🔷 [내용화면을 다른 곳에서 부를 수 있게 밖으로 빼내기] ⭐⭐⭐⭐⭐ 
                // [필요성]
                    // 현재, 내용화면은, event handlder 안에, 묶여 있음. 
                    // 클릭되어야만 -> 작동함. 
                    // ⭐⭐⭐⭐⭐ 라우터가 부를 수 있으려면, 밖으로 빼내야 함 ⭐⭐⭐⭐⭐⭐ 
            
            
            // 🔷 내용목록 함수를 호출하는 라우터 만들기 